# 如何自动生成.h文件

为什么需要自动生成.h文件呢？是因为有这样的需求，比如：

现在我们有这样一个结构体：

```C
struct foo {
    int a;
    short b;
};
```

在某一个文件`use.c`当中，我们需要知道`foo`的大小，理所应当使用`sizeof(struct foo)`对不对，但是这样我们就得把整个`struct foo`的定义暴露给`use.c`，在有些不想暴露结构体定义的场景中，这样是不合理的，所以我们需要通过生成`.h`文件，将`struct foo`的大小直接定义成宏，然后让`use.c` 包含即可。

下面用一个例子来说明如何自动生成.h文件：

> 需要注意的是，该方法只对编译内核有效

首先我们关注到`/include/linux/kbuild.h`文件，里面提供了一些宏供我们使用：

```C
/* SPDX-License-Identifier: GPL-2.0 */
#ifndef __LINUX_KBUILD_H
#define __LINUX_KBUILD_H

// 最终在.h文件里生成一个#define sym val
#define DEFINE(sym, val) \
	asm volatile("\n.ascii \"->" #sym " %0 " #val "\"" : : "i" (val))

// 最终在.h文件里生成一个空行
#define BLANK() asm volatile("\n.ascii \"->\"" : : )

// 结构体中某个成员的偏移
#define OFFSET(sym, str, mem) \
	DEFINE(sym, offsetof(struct str, mem))

// 最终在.h文件里生成一个注释
#define COMMENT(x) \
	asm volatile("\n.ascii \"->#" x "\"")

#endif
```

要使用上面这几个宏，我们首先定义一个.c文件：

```C
#include <linux/kbuild.h>
#include "buddy.h"

int main(void)
{
    DEFINE(STRUCT_PKVM_PAGE_SIZE, sizeof(struct pkvm_page));
    BLANK();
    COMMENT("this is comment");
    return 0;
}
```

然后编写一个Makefile，需要先编译成.s文件，再从.s文件生成.h文件:

```C
  always-y := include/pkvm_constants.h init/pkvm_constants.s

  define rule_gen_pkvm_constants
          $(call filechk,offsets,__PKVM_CONSTANTS_H__)
  endef

  $(obj)/init/pkvm_constants.s: $(src)/init/pkvm_constants.c FORCE
          $(call if_changed_dep,cc_s_c)

  $(obj)/include/pkvm_constants.h: $(obj)/init/pkvm_constants.s FORCE
          $(call if_changed_rule,gen_pkvm_constants)
```

先暂时不管这是什么意思，先看看生成的.h文件的结果：

```C
# pkvm_constants.h
#ifndef __PKVM_CONSTANTS_H__
#define __PKVM_CONSTANTS_H__
/*
   * DO NOT MODIFY.
   *
   * This file was generated by Kbuild
   */

#define STRUCT_PKVM_PAGE_SIZE 4 /* sizeof(struct pkvm_page) */

/* this is comment */

#endif
```

可以看到，最终生成的`pkvm_constants.h`文件里有一个#define的定义，其正好对应着之前的`DEFINE(STRUCT_PKVM_PAGE_SIZE, sizeof(struct pkvm_page));`，以及一个空行和一个注释。

## kbuild如何生成的.h文件？

下面我们来讲讲kbuild在背后做了哪些事情，让我们只需要简单的在C文件中使用DEFINE就可以生成.h文件的。

这是我们再来看之前在Makefile中生成的.s文件：

```C
# pkvm_constants.s
main:
# arch/x86/kvm/vmx/pkvm/init/pkvm_constants.c:6:        DEFINE(STRUCT_PKVM_PAGE_SIZE, sizeof(struct pkvm_page));
#APP
# 6 "arch/x86/kvm/vmx/pkvm/init/pkvm_constants.c" 1

.ascii "->STRUCT_PKVM_PAGE_SIZE $4 sizeof(struct pkvm_page)"    #
# 0 "" 2
# arch/x86/kvm/vmx/pkvm/init/pkvm_constants.c:7:        BLANK();
# 7 "arch/x86/kvm/vmx/pkvm/init/pkvm_constants.c" 1

.ascii "->"
# 0 "" 2
# arch/x86/kvm/vmx/pkvm/init/pkvm_constants.c:8:        COMMENT("this is comment");
# 8 "arch/x86/kvm/vmx/pkvm/init/pkvm_constants.c" 1

.ascii "->#this is comment"
```

可以看到在上面的.s文件中定义了很多的字符串，而每一个字符串就对应着最终的结果，而从该.s文件生成.h文件所做的应该也就是解析上述字符串，在Makefile中，我们使用了：

```C
$(call filechk,offsets,__PKVM_CONSTANTS_H__)
```

这个会调用以下内容，详细解析请看注释：

```C
// 解析字符串的脚本
define sed-y
	"/^->/{s:->#\(.*\):/* \1 */:; \
	s:^->\([^ ]*\) [\$$#]*\([-0-9]*\) \(.*\):#define \1 \2 /* \3 */:; \
	s:^->\([^ ]*\) [\$$#]*\([^ ]*\) \(.*\):#define \1 \2 /* \3 */:; \
	s:->::; p;}"
endef

define filechk_offsets
	(set -e; \
	 echo "#ifndef $2"; \	// 首先define传进来的__PKVM_CONSTANTS_H__
	 echo "#define $2"; \
	 echo "/*"; \
	 echo " * DO NOT MODIFY."; \
	 echo " *"; \
	 echo " * This file was generated by Kbuild"; \
	 echo " */"; \
	 echo ""; \
	 sed -ne $(sed-y); \	// 然后解析每一个字符串
	 echo ""; \
	 echo "#endif" )
endef
```

最终生成了.h文件。

## Reference

[filecheck,offsets](https://patchwork.kernel.org/project/linux-kbuild/patch/20170403193739.84905-1-mka@chromium.org/)

[Kbuild.include](http://www.macs.hw.ac.uk/~hwloidl/hackspace/linux/scripts/Kbuild.include)